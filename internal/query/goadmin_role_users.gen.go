// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ijidan/jsocial/internal/model"
)

func newGoadminRoleUsers(db *gorm.DB) goadminRoleUsers {
	_goadminRoleUsers := goadminRoleUsers{}

	_goadminRoleUsers.goadminRoleUsersDo.UseDB(db)
	_goadminRoleUsers.goadminRoleUsersDo.UseModel(&model.GoadminRoleUsers{})

	tableName := _goadminRoleUsers.goadminRoleUsersDo.TableName()
	_goadminRoleUsers.ALL = field.NewAsterisk(tableName)
	_goadminRoleUsers.RoleID = field.NewInt32(tableName, "role_id")
	_goadminRoleUsers.UserID = field.NewInt32(tableName, "user_id")
	_goadminRoleUsers.CreatedAt = field.NewTime(tableName, "created_at")
	_goadminRoleUsers.UpdatedAt = field.NewTime(tableName, "updated_at")

	_goadminRoleUsers.fillFieldMap()

	return _goadminRoleUsers
}

type goadminRoleUsers struct {
	goadminRoleUsersDo

	ALL       field.Asterisk
	RoleID    field.Int32
	UserID    field.Int32
	CreatedAt field.Time
	UpdatedAt field.Time

	fieldMap map[string]field.Expr
}

func (g goadminRoleUsers) Table(newTableName string) *goadminRoleUsers {
	g.goadminRoleUsersDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g goadminRoleUsers) As(alias string) *goadminRoleUsers {
	g.goadminRoleUsersDo.DO = *(g.goadminRoleUsersDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *goadminRoleUsers) updateTableName(table string) *goadminRoleUsers {
	g.ALL = field.NewAsterisk(table)
	g.RoleID = field.NewInt32(table, "role_id")
	g.UserID = field.NewInt32(table, "user_id")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")

	g.fillFieldMap()

	return g
}

func (g *goadminRoleUsers) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *goadminRoleUsers) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 4)
	g.fieldMap["role_id"] = g.RoleID
	g.fieldMap["user_id"] = g.UserID
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
}

func (g goadminRoleUsers) clone(db *gorm.DB) goadminRoleUsers {
	g.goadminRoleUsersDo.ReplaceDB(db)
	return g
}

type goadminRoleUsersDo struct{ gen.DO }

type IGoadminRoleUsersDo interface {
	gen.SubQuery
	Debug() IGoadminRoleUsersDo
	WithContext(ctx context.Context) IGoadminRoleUsersDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGoadminRoleUsersDo
	WriteDB() IGoadminRoleUsersDo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGoadminRoleUsersDo
	Not(conds ...gen.Condition) IGoadminRoleUsersDo
	Or(conds ...gen.Condition) IGoadminRoleUsersDo
	Select(conds ...field.Expr) IGoadminRoleUsersDo
	Where(conds ...gen.Condition) IGoadminRoleUsersDo
	Order(conds ...field.Expr) IGoadminRoleUsersDo
	Distinct(cols ...field.Expr) IGoadminRoleUsersDo
	Omit(cols ...field.Expr) IGoadminRoleUsersDo
	Join(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo
	Group(cols ...field.Expr) IGoadminRoleUsersDo
	Having(conds ...gen.Condition) IGoadminRoleUsersDo
	Limit(limit int) IGoadminRoleUsersDo
	Offset(offset int) IGoadminRoleUsersDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGoadminRoleUsersDo
	Unscoped() IGoadminRoleUsersDo
	Create(values ...*model.GoadminRoleUsers) error
	CreateInBatches(values []*model.GoadminRoleUsers, batchSize int) error
	Save(values ...*model.GoadminRoleUsers) error
	First() (*model.GoadminRoleUsers, error)
	Take() (*model.GoadminRoleUsers, error)
	Last() (*model.GoadminRoleUsers, error)
	Find() ([]*model.GoadminRoleUsers, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GoadminRoleUsers, err error)
	FindInBatches(result *[]*model.GoadminRoleUsers, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GoadminRoleUsers) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGoadminRoleUsersDo
	Assign(attrs ...field.AssignExpr) IGoadminRoleUsersDo
	Joins(fields ...field.RelationField) IGoadminRoleUsersDo
	Preload(fields ...field.RelationField) IGoadminRoleUsersDo
	FirstOrInit() (*model.GoadminRoleUsers, error)
	FirstOrCreate() (*model.GoadminRoleUsers, error)
	FindByPage(offset int, limit int) (result []*model.GoadminRoleUsers, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGoadminRoleUsersDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g goadminRoleUsersDo) Debug() IGoadminRoleUsersDo {
	return g.withDO(g.DO.Debug())
}

func (g goadminRoleUsersDo) WithContext(ctx context.Context) IGoadminRoleUsersDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g goadminRoleUsersDo) ReadDB() IGoadminRoleUsersDo {
	return g.Clauses(dbresolver.Read)
}

func (g goadminRoleUsersDo) WriteDB() IGoadminRoleUsersDo {
	return g.Clauses(dbresolver.Write)
}

func (g goadminRoleUsersDo) Clauses(conds ...clause.Expression) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g goadminRoleUsersDo) Returning(value interface{}, columns ...string) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g goadminRoleUsersDo) Not(conds ...gen.Condition) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g goadminRoleUsersDo) Or(conds ...gen.Condition) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g goadminRoleUsersDo) Select(conds ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g goadminRoleUsersDo) Where(conds ...gen.Condition) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g goadminRoleUsersDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IGoadminRoleUsersDo {
	return g.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (g goadminRoleUsersDo) Order(conds ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g goadminRoleUsersDo) Distinct(cols ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g goadminRoleUsersDo) Omit(cols ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g goadminRoleUsersDo) Join(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g goadminRoleUsersDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g goadminRoleUsersDo) RightJoin(table schema.Tabler, on ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g goadminRoleUsersDo) Group(cols ...field.Expr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g goadminRoleUsersDo) Having(conds ...gen.Condition) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g goadminRoleUsersDo) Limit(limit int) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g goadminRoleUsersDo) Offset(offset int) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g goadminRoleUsersDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g goadminRoleUsersDo) Unscoped() IGoadminRoleUsersDo {
	return g.withDO(g.DO.Unscoped())
}

func (g goadminRoleUsersDo) Create(values ...*model.GoadminRoleUsers) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g goadminRoleUsersDo) CreateInBatches(values []*model.GoadminRoleUsers, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g goadminRoleUsersDo) Save(values ...*model.GoadminRoleUsers) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g goadminRoleUsersDo) First() (*model.GoadminRoleUsers, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoadminRoleUsers), nil
	}
}

func (g goadminRoleUsersDo) Take() (*model.GoadminRoleUsers, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoadminRoleUsers), nil
	}
}

func (g goadminRoleUsersDo) Last() (*model.GoadminRoleUsers, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoadminRoleUsers), nil
	}
}

func (g goadminRoleUsersDo) Find() ([]*model.GoadminRoleUsers, error) {
	result, err := g.DO.Find()
	return result.([]*model.GoadminRoleUsers), err
}

func (g goadminRoleUsersDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GoadminRoleUsers, err error) {
	buf := make([]*model.GoadminRoleUsers, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g goadminRoleUsersDo) FindInBatches(result *[]*model.GoadminRoleUsers, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g goadminRoleUsersDo) Attrs(attrs ...field.AssignExpr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g goadminRoleUsersDo) Assign(attrs ...field.AssignExpr) IGoadminRoleUsersDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g goadminRoleUsersDo) Joins(fields ...field.RelationField) IGoadminRoleUsersDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g goadminRoleUsersDo) Preload(fields ...field.RelationField) IGoadminRoleUsersDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g goadminRoleUsersDo) FirstOrInit() (*model.GoadminRoleUsers, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoadminRoleUsers), nil
	}
}

func (g goadminRoleUsersDo) FirstOrCreate() (*model.GoadminRoleUsers, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GoadminRoleUsers), nil
	}
}

func (g goadminRoleUsersDo) FindByPage(offset int, limit int) (result []*model.GoadminRoleUsers, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g goadminRoleUsersDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g goadminRoleUsersDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g goadminRoleUsersDo) Delete(models ...*model.GoadminRoleUsers) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *goadminRoleUsersDo) withDO(do gen.Dao) *goadminRoleUsersDo {
	g.DO = *do.(*gen.DO)
	return g
}
